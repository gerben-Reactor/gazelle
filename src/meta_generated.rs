# [doc (hidden)] mod __meta_table { use super :: gazelle ; pub static ACTION_DATA : & [u32] = & [9u32 , 3u32 , 13u32 , 17u32 , 21u32 , 25u32 , 29u32 , 33u32 , 125u32 , 41u32 , 65u32 , 14u32 , 54u32 , 41u32 , 10u32 , 6u32 , 73u32 , 14u32 , 69u32 , 57u32 , 10u32 , 50u32 , 89u32 , 50u32 , 50u32 , 113u32 , 117u32 , 109u32 , 105u32 , 74u32 , 74u32 , 90u32 , 82u32 , 82u32 , 81u32 , 66u32 , 66u32 , 86u32 , 82u32 , 82u32 , 81u32 , 90u32 , 90u32 , 90u32 , 70u32 , 70u32 , 89u32 , 86u32 , 86u32 , 86u32 , 78u32 , 78u32 , 42u32 , 58u32 , 62u32 , 62u32 , 82u32 , 82u32 , 81u32 , 58u32 , 46u32 , 161u32 , 149u32 , 157u32 , 137u32 , 34u32 , 145u32 , 34u32 , 26u32 , 54u32 , 65u32 , 54u32 , 38u32 , 46u32 , 38u32 , 22u32 , 18u32 , 137u32 , 30u32 , 165u32 , 30u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32] ; pub static ACTION_BASE : & [i32] = & [- 2i32 , 1i32 , 1i32 , - 3i32 , 1i32 , 4i32 , - 6i32 , 3i32 , 2i32 , 8i32 , 2i32 , 10i32 , 12i32 , 13i32 , 15i32 , 6i32 , 17i32 , 14i32 , 21i32 , 14i32 , 26i32 , 27i32 , 30i32 , 18i32 , 24i32 , 33i32 , 36i32 , 39i32 , 45i32 , 52i32 , 43i32 , 59i32 , 54i32 , 58i32 , 51i32 , 61i32 , 67i32 , 62i32 , 65i32 , 72i32 , 74i32 , 75i32 , 71i32] ; pub static ACTION_CHECK : & [u32] = & [0u32 , 1u32 , 2u32 , 3u32 , 4u32 , 5u32 , 6u32 , 7u32 , 8u32 , 9u32 , 10u32 , 11u32 , 10u32 , 12u32 , 13u32 , 14u32 , 15u32 , 11u32 , 16u32 , 12u32 , 13u32 , 17u32 , 18u32 , 17u32 , 17u32 , 19u32 , 19u32 , 20u32 , 21u32 , 23u32 , 23u32 , 22u32 , 18u32 , 18u32 , 18u32 , 24u32 , 24u32 , 26u32 , 21u32 , 21u32 , 21u32 , 22u32 , 22u32 , 22u32 , 25u32 , 25u32 , 28u32 , 26u32 , 26u32 , 26u32 , 27u32 , 27u32 , 34u32 , 29u32 , 30u32 , 30u32 , 28u32 , 28u32 , 28u32 , 29u32 , 31u32 , 32u32 , 35u32 , 32u32 , 31u32 , 33u32 , 31u32 , 33u32 , 36u32 , 37u32 , 37u32 , 37u32 , 38u32 , 39u32 , 38u32 , 40u32 , 41u32 , 39u32 , 42u32 , 39u32 , 42u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32] ; pub static GOTO_DATA : & [u32] = & [1u32 , 9u32 , 12u32 , 15u32 , 13u32 , 25u32 , 38u32 , 0u32 , 11u32 , 19u32 , 24u32 , 23u32 , 21u32 , 30u32 , 23u32 , 21u32 , 32u32 , 33u32 , 35u32 , 42u32 , 35u32 , 0u32 , 0u32 , 0u32 , 0u32 , 0u32] ; pub static GOTO_BASE : & [i32] = & [0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , - 1i32 , 0i32 , 1i32 , - 3i32 , 0i32 , - 3i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 1i32 , 0i32 , 0i32 , - 5i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 4i32 , 0i32 , 0i32 , 13i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 0i32 , 15i32 , 0i32 , 0i32 , 0i32] ; pub static GOTO_CHECK : & [u32] = & [0u32 , 7u32 , 9u32 , 10u32 , 12u32 , 21u32 , 37u32 , 4294967295u32 , 9u32 , 18u32 , 18u32 , 18u32 , 18u32 , 28u32 , 28u32 , 28u32 , 31u32 , 31u32 , 31u32 , 39u32 , 39u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32 , 4294967295u32] ; pub static RULES : & [(u32 , u8)] = & [(26u32 , 1u8) , (14u32 , 9u8) , (15u32 , 2u8) , (15u32 , 1u8) , (16u32 , 5u8) , (16u32 , 4u8) , (16u32 , 3u8) , (17u32 , 3u8) , (17u32 , 1u8) , (18u32 , 3u8) , (19u32 , 1u8) , (19u32 , 0u8) , (20u32 , 2u8) , (20u32 , 0u8) , (21u32 , 5u8) , (22u32 , 3u8) , (22u32 , 1u8) , (23u32 , 2u8) , (23u32 , 1u8) , (24u32 , 2u8) , (24u32 , 0u8) , (25u32 , 2u8) , (25u32 , 1u8)] ; pub static STATE_SYMBOL : & [u32] = & [0u32 , 14u32 , 2u32 , 1u32 , 6u32 , 3u32 , 1u32 , 12u32 , 4u32 , 16u32 , 1u32 , 21u32 , 15u32 , 21u32 , 7u32 , 20u32 , 8u32 , 1u32 , 10u32 , 22u32 , 13u32 , 25u32 , 1u32 , 24u32 , 23u32 , 24u32 , 1u32 , 1u32 , 11u32 , 12u32 , 23u32 , 6u32 , 17u32 , 18u32 , 5u32 , 19u32 , 7u32 , 1u32 , 20u32 , 9u32 , 7u32 , 7u32 , 18u32] ; pub const NUM_STATES : usize = 43usize ; pub const NUM_TERMINALS : u32 = 13u32 ; # [allow (dead_code)] pub const NUM_NON_TERMINALS : u32 = 13u32 ; pub fn symbol_id (name : & str) -> gazelle :: SymbolId { match name { "COLON" => gazelle :: SymbolId (8u32) , "PIPE" => gazelle :: SymbolId (11u32) , "KW_GRAMMAR" => gazelle :: SymbolId (2u32) , "KW_TERMINALS" => gazelle :: SymbolId (4u32) , "EQ" => gazelle :: SymbolId (10u32) , "AT" => gazelle :: SymbolId (13u32) , "SEMI" => gazelle :: SymbolId (12u32) , "LBRACE" => gazelle :: SymbolId (6u32) , "IDENT" => gazelle :: SymbolId (1u32) , "KW_PREC" => gazelle :: SymbolId (5u32) , "KW_START" => gazelle :: SymbolId (3u32) , "COMMA" => gazelle :: SymbolId (9u32) , "RBRACE" => gazelle :: SymbolId (7u32) , "grammar_def" => gazelle :: SymbolId (14u32) , "rules" => gazelle :: SymbolId (15u32) , "terminals_block" => gazelle :: SymbolId (16u32) , "terminal_list" => gazelle :: SymbolId (17u32) , "terminal_item" => gazelle :: SymbolId (18u32) , "prec_opt" => gazelle :: SymbolId (19u32) , "type_opt" => gazelle :: SymbolId (20u32) , "rule" => gazelle :: SymbolId (21u32) , "alts" => gazelle :: SymbolId (22u32) , "alt" => gazelle :: SymbolId (23u32) , "name_opt" => gazelle :: SymbolId (24u32) , "seq" => gazelle :: SymbolId (25u32) , _ => panic ! ("unknown symbol: {}" , name) , } } } # [doc = r" Terminal symbols for the parser."] # [derive (Debug , Clone)] pub enum MetaTerminal { Colon , Pipe , KwGrammar , KwTerminals , Eq , At , Semi , Lbrace , Ident (Ident) , KwPrec , KwStart , Comma , Rbrace } impl MetaTerminal { # [doc = r" Get the symbol ID for this terminal."] pub fn symbol_id (& self) -> gazelle :: SymbolId { match self { Self :: Colon => gazelle :: SymbolId (8u32) , Self :: Pipe => gazelle :: SymbolId (11u32) , Self :: KwGrammar => gazelle :: SymbolId (2u32) , Self :: KwTerminals => gazelle :: SymbolId (4u32) , Self :: Eq => gazelle :: SymbolId (10u32) , Self :: At => gazelle :: SymbolId (13u32) , Self :: Semi => gazelle :: SymbolId (12u32) , Self :: Lbrace => gazelle :: SymbolId (6u32) , Self :: Ident (_) => gazelle :: SymbolId (1u32) , Self :: KwPrec => gazelle :: SymbolId (5u32) , Self :: KwStart => gazelle :: SymbolId (3u32) , Self :: Comma => gazelle :: SymbolId (9u32) , Self :: Rbrace => gazelle :: SymbolId (7u32) , } } # [doc = r" Convert to a gazelle Token for parsing."] pub fn to_token (& self , symbol_ids : & impl Fn (& str) -> gazelle :: SymbolId) -> gazelle :: Token { match self { Self :: Colon => gazelle :: Token :: new (symbol_ids ("COLON") , "COLON") , Self :: Pipe => gazelle :: Token :: new (symbol_ids ("PIPE") , "PIPE") , Self :: KwGrammar => gazelle :: Token :: new (symbol_ids ("KW_GRAMMAR") , "KW_GRAMMAR") , Self :: KwTerminals => gazelle :: Token :: new (symbol_ids ("KW_TERMINALS") , "KW_TERMINALS") , Self :: Eq => gazelle :: Token :: new (symbol_ids ("EQ") , "EQ") , Self :: At => gazelle :: Token :: new (symbol_ids ("AT") , "AT") , Self :: Semi => gazelle :: Token :: new (symbol_ids ("SEMI") , "SEMI") , Self :: Lbrace => gazelle :: Token :: new (symbol_ids ("LBRACE") , "LBRACE") , Self :: Ident (_) => gazelle :: Token :: new (symbol_ids ("IDENT") , "IDENT") , Self :: KwPrec => gazelle :: Token :: new (symbol_ids ("KW_PREC") , "KW_PREC") , Self :: KwStart => gazelle :: Token :: new (symbol_ids ("KW_START") , "KW_START") , Self :: Comma => gazelle :: Token :: new (symbol_ids ("COMMA") , "COMMA") , Self :: Rbrace => gazelle :: Token :: new (symbol_ids ("RBRACE") , "RBRACE") , } } # [doc = r" Get precedence for runtime precedence comparison."] # [doc = r" Returns (level, assoc) where assoc: 0=left, 1=right."] pub fn precedence (& self) -> Option < (u8 , u8) > { match self { Self :: Colon => None , Self :: Pipe => None , Self :: KwGrammar => None , Self :: KwTerminals => None , Self :: Eq => None , Self :: At => None , Self :: Semi => None , Self :: Lbrace => None , Self :: Ident (_) => None , Self :: KwPrec => None , Self :: KwStart => None , Self :: Comma => None , Self :: Rbrace => None , } } } # [doc = r" Parse error."] # [derive (Debug , Clone)] pub struct MetaError { # [doc = r" The parser state when error occurred."] pub state : usize , } # [doc = r" Actions trait for parser callbacks."] pub trait MetaActions { type GrammarDef ; type Rules ; type TerminalsBlock ; type TerminalList ; type TerminalItem ; type PrecOpt ; type TypeOpt ; type Rule ; type Alts ; type Alt ; type NameOpt ; type Seq ; fn grammar_def (& mut self , v0 : Ident , v1 : Ident , v2 : Self :: TerminalsBlock , v3 : Self :: Rules) -> Self :: GrammarDef ; fn rules_append (& mut self , v0 : Self :: Rules , v1 : Self :: Rule) -> Self :: Rules ; fn rules_single (& mut self , v0 : Self :: Rule) -> Self :: Rules ; fn terminals_trailing (& mut self , v0 : Self :: TerminalList) -> Self :: TerminalsBlock ; fn terminals_block (& mut self , v0 : Self :: TerminalList) -> Self :: TerminalsBlock ; fn terminals_empty (& mut self ,) -> Self :: TerminalsBlock ; fn terminal_list_append (& mut self , v0 : Self :: TerminalList , v1 : Self :: TerminalItem) -> Self :: TerminalList ; fn terminal_list_single (& mut self , v0 : Self :: TerminalItem) -> Self :: TerminalList ; fn terminal_item (& mut self , v0 : Self :: PrecOpt , v1 : Ident , v2 : Self :: TypeOpt) -> Self :: TerminalItem ; fn prec_yes (& mut self ,) -> Self :: PrecOpt ; fn prec_no (& mut self ,) -> Self :: PrecOpt ; fn type_some (& mut self , v0 : Ident) -> Self :: TypeOpt ; fn type_none (& mut self ,) -> Self :: TypeOpt ; fn rule (& mut self , v0 : Ident , v1 : Self :: TypeOpt , v2 : Self :: Alts) -> Self :: Rule ; fn alts_append (& mut self , v0 : Self :: Alts , v1 : Self :: Alt) -> Self :: Alts ; fn alts_single (& mut self , v0 : Self :: Alt) -> Self :: Alts ; fn alt (& mut self , v0 : Self :: Seq , v1 : Self :: NameOpt) -> Self :: Alt ; fn alt_empty (& mut self , v0 : Self :: NameOpt) -> Self :: Alt ; fn name_some (& mut self , v0 : Ident) -> Self :: NameOpt ; fn name_none (& mut self ,) -> Self :: NameOpt ; fn seq_append (& mut self , v0 : Self :: Seq , v1 : Ident) -> Self :: Seq ; fn seq_single (& mut self , v0 : Ident) -> Self :: Seq ; } # [doc (hidden)] union __MetaValue < A : MetaActions > { __ident : std :: mem :: ManuallyDrop < Ident > , __grammar_def : std :: mem :: ManuallyDrop < A :: GrammarDef > , __rules : std :: mem :: ManuallyDrop < A :: Rules > , __terminals_block : std :: mem :: ManuallyDrop < A :: TerminalsBlock > , __terminal_list : std :: mem :: ManuallyDrop < A :: TerminalList > , __terminal_item : std :: mem :: ManuallyDrop < A :: TerminalItem > , __prec_opt : std :: mem :: ManuallyDrop < A :: PrecOpt > , __type_opt : std :: mem :: ManuallyDrop < A :: TypeOpt > , __rule : std :: mem :: ManuallyDrop < A :: Rule > , __alts : std :: mem :: ManuallyDrop < A :: Alts > , __alt : std :: mem :: ManuallyDrop < A :: Alt > , __name_opt : std :: mem :: ManuallyDrop < A :: NameOpt > , __seq : std :: mem :: ManuallyDrop < A :: Seq > , __unit : () , } # [doc = r" Type-safe LR parser."] pub struct MetaParser < A : MetaActions > { state_stack : Vec < (usize , Option < (u8 , u8) >) > , value_stack : Vec < std :: mem :: ManuallyDrop < __MetaValue < A >> > , } impl < A : MetaActions > MetaParser < A > { # [doc = r" Create a new parser instance."] pub fn new () -> Self { Self { state_stack : vec ! [(0 , None)] , value_stack : Vec :: new () , } } # [doc = r" Push a terminal, performing any reductions."] pub fn push (& mut self , terminal : MetaTerminal , actions : & mut A) -> Result < () , MetaError > { let token_prec = terminal . precedence () ; loop { let (state , stack_prec) = self . current_state_and_prec () ; let symbol_id = terminal . symbol_id () . 0 ; let action = self . lookup_action (state , symbol_id) ; match action & 3 { 0 => return Err (MetaError { state }) , 1 => { let next_state = (action >> 2) as usize ; self . do_shift (& terminal , next_state , token_prec) ; return Ok (()) ; } 2 => { let rule = (action >> 2) as usize ; self . do_reduce (rule , actions) ; } 3 if action != 3 => { let shift_state = ((action >> 3) & 0x3FFF) as usize ; let reduce_rule = (action >> 17) as usize ; let should_shift = match (stack_prec , token_prec) { (Some ((sp , _)) , Some ((tp , assoc))) => { if tp > sp { true } else if tp < sp { false } else { assoc == 1 } } _ => true , } ; if should_shift { self . do_shift (& terminal , shift_state , token_prec) ; return Ok (()) ; } else { self . do_reduce (reduce_rule , actions) ; } } _ => return Err (MetaError { state }) , } } } # [doc = r" Finish parsing and return the result."] pub fn finish (mut self , actions : & mut A) -> Result < A :: GrammarDef , MetaError > { loop { let state = self . current_state () ; let action = self . lookup_action (state , 0) ; match action & 3 { 2 => { let rule = (action >> 2) as usize ; self . do_reduce (rule , actions) ; } 3 => { if action == 3 { if let Some (value) = self . value_stack . pop () { self . state_stack . pop () ; let union_val = std :: mem :: ManuallyDrop :: into_inner (value) ; return Ok (unsafe { std :: mem :: ManuallyDrop :: into_inner (union_val . __grammar_def) }) ; } } else { let reduce_rule = (action >> 17) as usize ; self . do_reduce (reduce_rule , actions) ; } } _ => return Err (MetaError { state }) , } } } # [doc = r" Get the current parser state."] pub fn state (& self) -> usize { self . current_state () } fn current_state (& self) -> usize { self . state_stack . last () . unwrap () . 0 } fn current_state_and_prec (& self) -> (usize , Option < (u8 , u8) >) { let (state , _) = * self . state_stack . last () . unwrap () ; let prec = self . state_stack . iter () . rev () . find_map (| (_ , p) | * p) ; (state , prec) } fn lookup_action (& self , state : usize , terminal : u32) -> u32 { let base = __meta_table :: ACTION_BASE [state] ; let index = base . wrapping_add (terminal as i32) as usize ; if index < __meta_table :: ACTION_CHECK . len () && __meta_table :: ACTION_CHECK [index] == state as u32 { __meta_table :: ACTION_DATA [index] } else { 0 } } fn lookup_goto (& self , state : usize , non_terminal : u32) -> Option < usize > { let base = __meta_table :: GOTO_BASE [state] ; let index = base . wrapping_add (non_terminal as i32) as usize ; if index < __meta_table :: GOTO_CHECK . len () && __meta_table :: GOTO_CHECK [index] == state as u32 { Some (__meta_table :: GOTO_DATA [index] as usize) } else { None } } fn do_shift (& mut self , terminal : & MetaTerminal , next_state : usize , prec : Option < (u8 , u8) >) { self . state_stack . push ((next_state , prec)) ; match terminal { MetaTerminal :: Colon => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Pipe => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: KwGrammar => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: KwTerminals => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Eq => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: At => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Semi => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Lbrace => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Ident (v) => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __ident : std :: mem :: ManuallyDrop :: new (v . clone ()) })) ; } MetaTerminal :: KwPrec => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: KwStart => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Comma => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } MetaTerminal :: Rbrace => { self . value_stack . push (std :: mem :: ManuallyDrop :: new (__MetaValue { __unit : () })) ; } } } fn do_reduce (& mut self , rule : usize , actions : & mut A) { if rule == 0 { return ; } let (lhs_id , rhs_len) = __meta_table :: RULES [rule] ; let rhs_len = rhs_len as usize ; for _ in 0 .. rhs_len { self . state_stack . pop () ; } let original_rule_idx = rule - 1 ; let value = match original_rule_idx { 0usize => { { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v7 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __rules) } ; let v6 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __terminals_block) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v4 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __grammar_def : std :: mem :: ManuallyDrop :: new (actions . grammar_def (v1 , v4 , v6 , v7)) } } 1usize => { let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __rule) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __rules) } ; __MetaValue { __rules : std :: mem :: ManuallyDrop :: new (actions . rules_append (v0 , v1)) } } 2usize => { let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __rule) } ; __MetaValue { __rules : std :: mem :: ManuallyDrop :: new (actions . rules_single (v0)) } } 3usize => { { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v2 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __terminal_list) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __terminals_block : std :: mem :: ManuallyDrop :: new (actions . terminals_trailing (v2)) } } 4usize => { { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v2 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __terminal_list) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __terminals_block : std :: mem :: ManuallyDrop :: new (actions . terminals_block (v2)) } } 5usize => { { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __terminals_block : std :: mem :: ManuallyDrop :: new (actions . terminals_empty ()) } } 6usize => { let v2 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __terminal_item) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __terminal_list) } ; __MetaValue { __terminal_list : std :: mem :: ManuallyDrop :: new (actions . terminal_list_append (v0 , v2)) } } 7usize => { let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __terminal_item) } ; __MetaValue { __terminal_list : std :: mem :: ManuallyDrop :: new (actions . terminal_list_single (v0)) } } 8usize => { let v2 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __type_opt) } ; let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __prec_opt) } ; __MetaValue { __terminal_item : std :: mem :: ManuallyDrop :: new (actions . terminal_item (v0 , v1 , v2)) } } 9usize => { { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __prec_opt : std :: mem :: ManuallyDrop :: new (actions . prec_yes ()) } } 10usize => { __MetaValue { __prec_opt : std :: mem :: ManuallyDrop :: new (actions . prec_no ()) } } 11usize => { let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __type_opt : std :: mem :: ManuallyDrop :: new (actions . type_some (v1)) } } 12usize => { __MetaValue { __type_opt : std :: mem :: ManuallyDrop :: new (actions . type_none ()) } } 13usize => { { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v3 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __alts) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __type_opt) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; __MetaValue { __rule : std :: mem :: ManuallyDrop :: new (actions . rule (v0 , v1 , v3)) } } 14usize => { let v2 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __alt) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __alts) } ; __MetaValue { __alts : std :: mem :: ManuallyDrop :: new (actions . alts_append (v0 , v2)) } } 15usize => { let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __alt) } ; __MetaValue { __alts : std :: mem :: ManuallyDrop :: new (actions . alts_single (v0)) } } 16usize => { let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __name_opt) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __seq) } ; __MetaValue { __alt : std :: mem :: ManuallyDrop :: new (actions . alt (v0 , v1)) } } 17usize => { let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __name_opt) } ; __MetaValue { __alt : std :: mem :: ManuallyDrop :: new (actions . alt_empty (v0)) } } 18usize => { let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; { std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) } ; __MetaValue { __name_opt : std :: mem :: ManuallyDrop :: new (actions . name_some (v1)) } } 19usize => { __MetaValue { __name_opt : std :: mem :: ManuallyDrop :: new (actions . name_none ()) } } 20usize => { let v1 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __seq) } ; __MetaValue { __seq : std :: mem :: ManuallyDrop :: new (actions . seq_append (v0 , v1)) } } 21usize => { let v0 = unsafe { std :: mem :: ManuallyDrop :: into_inner (std :: mem :: ManuallyDrop :: into_inner (self . value_stack . pop () . unwrap ()) . __ident) } ; __MetaValue { __seq : std :: mem :: ManuallyDrop :: new (actions . seq_single (v0)) } } _ => return , } ; self . value_stack . push (std :: mem :: ManuallyDrop :: new (value)) ; let goto_state = self . current_state () ; let nt_index = lhs_id - __meta_table :: NUM_TERMINALS - 1 ; if let Some (next_state) = self . lookup_goto (goto_state , nt_index) { self . state_stack . push ((next_state , None)) ; } } } impl < A : MetaActions > Default for MetaParser < A > { fn default () -> Self { Self :: new () } } impl < A : MetaActions > Drop for MetaParser < A > { fn drop (& mut self) { while let Some (value) = self . value_stack . pop () { let (state , _) = self . state_stack . pop () . unwrap () ; let sym_id = __meta_table :: STATE_SYMBOL [state] ; unsafe { let union_val = std :: mem :: ManuallyDrop :: into_inner (value) ; match sym_id { 1u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __ident) ; } 14u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __grammar_def) ; } 15u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __rules) ; } 16u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __terminals_block) ; } 17u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __terminal_list) ; } 18u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __terminal_item) ; } 19u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __prec_opt) ; } 20u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __type_opt) ; } 21u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __rule) ; } 22u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __alts) ; } 23u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __alt) ; } 24u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __name_opt) ; } 25u32 => { std :: mem :: ManuallyDrop :: into_inner (union_val . __seq) ; } _ => { } } } } } }
