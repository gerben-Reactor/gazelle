#[doc(hidden)]
mod __meta_table {
    use super::gazelle;
    pub static ACTION_DATA: &[u32] = &[
        9u32, 3u32, 13u32, 17u32, 21u32, 25u32, 29u32, 33u32, 149u32, 49u32, 94u32,
        49u32, 57u32, 69u32, 78u32, 65u32, 94u32, 145u32, 74u32, 93u32, 74u32, 74u32,
        30u32, 105u32, 30u32, 30u32, 129u32, 133u32, 86u32, 102u32, 102u32, 101u32,
        98u32, 98u32, 42u32, 42u32, 93u32, 6u32, 86u32, 86u32, 86u32, 70u32, 50u32,
        50u32, 54u32, 54u32, 102u32, 102u32, 101u32, 58u32, 173u32, 70u32, 70u32, 70u32,
        109u32, 117u32, 113u32, 66u32, 14u32, 58u32, 58u32, 58u32, 62u32, 46u32, 46u32,
        82u32, 106u32, 66u32, 66u32, 66u32, 93u32, 193u32, 62u32, 62u32, 62u32, 82u32,
        82u32, 82u32, 34u32, 10u32, 102u32, 102u32, 101u32, 90u32, 34u32, 38u32, 38u32,
        110u32, 22u32, 90u32, 22u32, 169u32, 118u32, 165u32, 185u32, 78u32, 57u32, 78u32,
        26u32, 110u32, 26u32, 0u32, 18u32, 169u32, 18u32, 114u32, 0u32, 0u32, 0u32, 0u32,
        0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
        0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
    ];
    pub static ACTION_BASE: &[i32] = &[
        -2i32,
        1i32,
        1i32,
        -3i32,
        1i32,
        4i32,
        -6i32,
        3i32,
        2i32,
        8i32,
        9i32,
        10i32,
        4i32,
        3i32,
        14i32,
        11i32,
        15i32,
        18i32,
        15i32,
        21i32,
        27i32,
        23i32,
        35i32,
        40i32,
        31i32,
        22i32,
        33i32,
        48i32,
        56i32,
        61i32,
        52i32,
        64i32,
        69i32,
        77i32,
        74i32,
        82i32,
        37i32,
        86i32,
        81i32,
        85i32,
        49i32,
        57i32,
        65i32,
        88i32,
        91i32,
        64i32,
        98i32,
        95i32,
        78i32,
    ];
    pub static ACTION_CHECK: &[u32] = &[
        0u32, 1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 10u32, 11u32, 12u32,
        13u32, 12u32, 14u32, 10u32, 11u32, 15u32, 17u32, 15u32, 15u32, 16u32, 25u32,
        16u32, 16u32, 18u32, 18u32, 20u32, 17u32, 17u32, 17u32, 19u32, 19u32, 21u32,
        21u32, 22u32, 36u32, 20u32, 20u32, 20u32, 23u32, 24u32, 24u32, 26u32, 26u32,
        22u32, 22u32, 22u32, 27u32, 40u32, 23u32, 23u32, 23u32, 23u32, 23u32, 23u32,
        28u32, 41u32, 27u32, 27u32, 27u32, 29u32, 30u32, 30u32, 31u32, 42u32, 28u32,
        28u32, 28u32, 32u32, 45u32, 29u32, 29u32, 29u32, 31u32, 31u32, 31u32, 33u32,
        48u32, 32u32, 32u32, 32u32, 35u32, 33u32, 34u32, 34u32, 37u32, 38u32, 35u32,
        38u32, 37u32, 39u32, 37u32, 39u32, 43u32, 43u32, 43u32, 44u32, 46u32, 44u32,
        4294967295u32, 47u32, 46u32, 47u32, 46u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32,
    ];
    pub static GOTO_DATA: &[u32] = &[
        1u32, 9u32, 10u32, 35u32, 15u32, 39u32, 38u32, 45u32, 0u32, 11u32, 13u32, 18u32,
        21u32, 19u32, 20u32, 0u32, 22u32, 40u32, 24u32, 19u32, 31u32, 34u32, 19u32,
        20u32, 30u32, 22u32, 15u32, 24u32, 47u32, 0u32, 0u32, 0u32, 44u32, 0u32, 0u32,
        0u32, 0u32, 0u32, 0u32, 40u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
        0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
        0u32, 0u32, 0u32, 0u32, 0u32, 0u32, 0u32,
    ];
    pub static GOTO_BASE: &[i32] = &[
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        -3i32,
        0i32,
        -2i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        5i32,
        0i32,
        0i32,
        0i32,
        0i32,
        11i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        0i32,
        14i32,
        0i32,
        0i32,
        0i32,
        0i32,
        3i32,
        0i32,
        -8i32,
        0i32,
        0i32,
        0i32,
        22i32,
        0i32,
        0i32,
        25i32,
        0i32,
        0i32,
    ];
    pub static GOTO_CHECK: &[u32] = &[
        0u32, 7u32, 9u32, 11u32, 12u32, 37u32, 37u32, 39u32, 4294967295u32, 9u32, 12u32,
        17u32, 17u32, 17u32, 17u32, 4294967295u32, 17u32, 37u32, 17u32, 22u32, 22u32,
        32u32, 32u32, 32u32, 22u32, 32u32, 43u32, 32u32, 46u32, 4294967295u32,
        4294967295u32, 4294967295u32, 43u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 46u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32, 4294967295u32,
        4294967295u32,
    ];
    pub static RULES: &[(u32, u8)] = &[
        (33u32, 1u8),
        (17u32, 9u8),
        (18u32, 5u8),
        (18u32, 3u8),
        (19u32, 3u8),
        (19u32, 1u8),
        (20u32, 3u8),
        (21u32, 2u8),
        (22u32, 5u8),
        (23u32, 3u8),
        (23u32, 1u8),
        (24u32, 2u8),
        (24u32, 1u8),
        (25u32, 2u8),
        (26u32, 2u8),
        (26u32, 2u8),
        (26u32, 2u8),
        (26u32, 1u8),
        (27u32, 1u8),
        (27u32, 0u8),
        (28u32, 2u8),
        (28u32, 1u8),
        (29u32, 2u8),
        (29u32, 1u8),
        (30u32, 1u8),
        (30u32, 0u8),
        (31u32, 1u8),
        (31u32, 0u8),
        (32u32, 1u8),
        (32u32, 0u8),
    ];
    pub static STATE_SYMBOL: &[u32] = &[
        0u32, 17u32, 2u32, 1u32, 6u32, 3u32, 1u32, 12u32, 4u32, 18u32, 22u32, 29u32,
        1u32, 27u32, 8u32, 21u32, 1u32, 10u32, 23u32, 25u32, 26u32, 24u32, 28u32, 1u32,
        30u32, 13u32, 1u32, 14u32, 16u32, 15u32, 30u32, 26u32, 11u32, 12u32, 24u32,
        22u32, 7u32, 6u32, 20u32, 19u32, 31u32, 7u32, 5u32, 1u32, 27u32, 32u32, 9u32,
        20u32, 7u32,
    ];
    pub const NUM_STATES: usize = 49usize;
    pub const NUM_TERMINALS: u32 = 16u32;
    #[allow(dead_code)]
    pub const NUM_NON_TERMINALS: u32 = 17u32;
    pub fn symbol_id(name: &str) -> gazelle::SymbolId {
        match name {
            "COLON" => gazelle::SymbolId(8u32),
            "PLUS" => gazelle::SymbolId(16u32),
            "KW_PREC" => gazelle::SymbolId(5u32),
            "KW_GRAMMAR" => gazelle::SymbolId(2u32),
            "AT" => gazelle::SymbolId(13u32),
            "SEMI" => gazelle::SymbolId(12u32),
            "QUESTION" => gazelle::SymbolId(14u32),
            "STAR" => gazelle::SymbolId(15u32),
            "KW_START" => gazelle::SymbolId(3u32),
            "RBRACE" => gazelle::SymbolId(7u32),
            "COMMA" => gazelle::SymbolId(9u32),
            "KW_TERMINALS" => gazelle::SymbolId(4u32),
            "EQ" => gazelle::SymbolId(10u32),
            "LBRACE" => gazelle::SymbolId(6u32),
            "IDENT" => gazelle::SymbolId(1u32),
            "PIPE" => gazelle::SymbolId(11u32),
            "grammar_def" => gazelle::SymbolId(17u32),
            "terminals_block" => gazelle::SymbolId(18u32),
            "terminal_list" => gazelle::SymbolId(19u32),
            "terminal_item" => gazelle::SymbolId(20u32),
            "type_annot" => gazelle::SymbolId(21u32),
            "rule" => gazelle::SymbolId(22u32),
            "alts" => gazelle::SymbolId(23u32),
            "alt" => gazelle::SymbolId(24u32),
            "action_name" => gazelle::SymbolId(25u32),
            "symbol" => gazelle::SymbolId(26u32),
            "__type_annot_opt" => gazelle::SymbolId(27u32),
            "__symbol_plus" => gazelle::SymbolId(28u32),
            "__rule_plus" => gazelle::SymbolId(29u32),
            "__action_name_opt" => gazelle::SymbolId(30u32),
            "__kw_prec_opt" => gazelle::SymbolId(31u32),
            "__comma_opt" => gazelle::SymbolId(32u32),
            _ => panic!("unknown symbol: {}", name),
        }
    }
}
/// Terminal symbols for the parser.
pub enum MetaTerminal<A: MetaActions> {
    Colon,
    Plus,
    KwPrec,
    KwGrammar,
    At,
    Semi,
    Question,
    Star,
    KwStart,
    Rbrace,
    Comma,
    KwTerminals,
    Eq,
    Lbrace,
    Ident(A::Ident),
    Pipe,
    #[doc(hidden)]
    __Phantom(std::marker::PhantomData<A>),
}
impl<A: MetaActions> MetaTerminal<A> {
    /// Get the symbol ID for this terminal.
    pub fn symbol_id(&self) -> gazelle::SymbolId {
        match self {
            Self::Colon => gazelle::SymbolId(8u32),
            Self::Plus => gazelle::SymbolId(16u32),
            Self::KwPrec => gazelle::SymbolId(5u32),
            Self::KwGrammar => gazelle::SymbolId(2u32),
            Self::At => gazelle::SymbolId(13u32),
            Self::Semi => gazelle::SymbolId(12u32),
            Self::Question => gazelle::SymbolId(14u32),
            Self::Star => gazelle::SymbolId(15u32),
            Self::KwStart => gazelle::SymbolId(3u32),
            Self::Rbrace => gazelle::SymbolId(7u32),
            Self::Comma => gazelle::SymbolId(9u32),
            Self::KwTerminals => gazelle::SymbolId(4u32),
            Self::Eq => gazelle::SymbolId(10u32),
            Self::Lbrace => gazelle::SymbolId(6u32),
            Self::Ident(_) => gazelle::SymbolId(1u32),
            Self::Pipe => gazelle::SymbolId(11u32),
            Self::__Phantom(_) => unreachable!(),
        }
    }
    /// Convert to a gazelle Token for parsing.
    pub fn to_token(
        &self,
        symbol_ids: &impl Fn(&str) -> gazelle::SymbolId,
    ) -> gazelle::Token {
        match self {
            Self::Colon => gazelle::Token::new(symbol_ids("COLON"), "COLON"),
            Self::Plus => gazelle::Token::new(symbol_ids("PLUS"), "PLUS"),
            Self::KwPrec => gazelle::Token::new(symbol_ids("KW_PREC"), "KW_PREC"),
            Self::KwGrammar => {
                gazelle::Token::new(symbol_ids("KW_GRAMMAR"), "KW_GRAMMAR")
            }
            Self::At => gazelle::Token::new(symbol_ids("AT"), "AT"),
            Self::Semi => gazelle::Token::new(symbol_ids("SEMI"), "SEMI"),
            Self::Question => gazelle::Token::new(symbol_ids("QUESTION"), "QUESTION"),
            Self::Star => gazelle::Token::new(symbol_ids("STAR"), "STAR"),
            Self::KwStart => gazelle::Token::new(symbol_ids("KW_START"), "KW_START"),
            Self::Rbrace => gazelle::Token::new(symbol_ids("RBRACE"), "RBRACE"),
            Self::Comma => gazelle::Token::new(symbol_ids("COMMA"), "COMMA"),
            Self::KwTerminals => {
                gazelle::Token::new(symbol_ids("KW_TERMINALS"), "KW_TERMINALS")
            }
            Self::Eq => gazelle::Token::new(symbol_ids("EQ"), "EQ"),
            Self::Lbrace => gazelle::Token::new(symbol_ids("LBRACE"), "LBRACE"),
            Self::Ident(_) => gazelle::Token::new(symbol_ids("IDENT"), "IDENT"),
            Self::Pipe => gazelle::Token::new(symbol_ids("PIPE"), "PIPE"),
            Self::__Phantom(_) => unreachable!(),
        }
    }
    /// Get precedence for runtime precedence comparison.
    /// Returns (level, assoc) where assoc: 0=left, 1=right.
    pub fn precedence(&self) -> Option<(u8, u8)> {
        match self {
            Self::Colon => None,
            Self::Plus => None,
            Self::KwPrec => None,
            Self::KwGrammar => None,
            Self::At => None,
            Self::Semi => None,
            Self::Question => None,
            Self::Star => None,
            Self::KwStart => None,
            Self::Rbrace => None,
            Self::Comma => None,
            Self::KwTerminals => None,
            Self::Eq => None,
            Self::Lbrace => None,
            Self::Ident(_) => None,
            Self::Pipe => None,
            Self::__Phantom(_) => unreachable!(),
        }
    }
}
/// Parse error.
#[derive(Debug, Clone)]
pub struct MetaError {
    /// The parser state when error occurred.
    pub state: usize,
}
/// Actions trait for parser callbacks.
pub trait MetaActions {
    type Ident;
    type GrammarDef;
    type TerminalsBlock;
    type TerminalList;
    type TerminalItem;
    type TypeAnnot;
    type Rule;
    type Alts;
    type Alt;
    type ActionName;
    type Symbol;
    fn grammar_def(
        &mut self,
        v0: Self::Ident,
        v1: Self::Ident,
        v2: Self::TerminalsBlock,
        v3: Vec<Self::Rule>,
    ) -> Self::GrammarDef;
    fn terminals_block(
        &mut self,
        v0: Self::TerminalList,
        v1: Option<()>,
    ) -> Self::TerminalsBlock;
    fn terminals_empty(&mut self) -> Self::TerminalsBlock;
    fn terminal_list_append(
        &mut self,
        v0: Self::TerminalList,
        v1: Self::TerminalItem,
    ) -> Self::TerminalList;
    fn terminal_list_single(&mut self, v0: Self::TerminalItem) -> Self::TerminalList;
    fn terminal_item(
        &mut self,
        v0: Option<()>,
        v1: Self::Ident,
        v2: Option<Self::TypeAnnot>,
    ) -> Self::TerminalItem;
    fn type_annot(&mut self, v0: Self::Ident) -> Self::TypeAnnot;
    fn rule(
        &mut self,
        v0: Self::Ident,
        v1: Option<Self::TypeAnnot>,
        v2: Self::Alts,
    ) -> Self::Rule;
    fn alts_append(&mut self, v0: Self::Alts, v1: Self::Alt) -> Self::Alts;
    fn alts_single(&mut self, v0: Self::Alt) -> Self::Alts;
    fn alt(&mut self, v0: Vec<Self::Symbol>, v1: Option<Self::ActionName>) -> Self::Alt;
    fn alt_empty(&mut self, v0: Option<Self::ActionName>) -> Self::Alt;
    fn action_name(&mut self, v0: Self::Ident) -> Self::ActionName;
    fn sym_opt(&mut self, v0: Self::Ident) -> Self::Symbol;
    fn sym_star(&mut self, v0: Self::Ident) -> Self::Symbol;
    fn sym_plus(&mut self, v0: Self::Ident) -> Self::Symbol;
    fn sym_plain(&mut self, v0: Self::Ident) -> Self::Symbol;
}
#[doc(hidden)]
union __MetaValue<A: MetaActions> {
    __ident: std::mem::ManuallyDrop<A::Ident>,
    __grammar_def: std::mem::ManuallyDrop<A::GrammarDef>,
    __terminals_block: std::mem::ManuallyDrop<A::TerminalsBlock>,
    __terminal_list: std::mem::ManuallyDrop<A::TerminalList>,
    __terminal_item: std::mem::ManuallyDrop<A::TerminalItem>,
    __type_annot: std::mem::ManuallyDrop<A::TypeAnnot>,
    __rule: std::mem::ManuallyDrop<A::Rule>,
    __alts: std::mem::ManuallyDrop<A::Alts>,
    __alt: std::mem::ManuallyDrop<A::Alt>,
    __action_name: std::mem::ManuallyDrop<A::ActionName>,
    __symbol: std::mem::ManuallyDrop<A::Symbol>,
    ____type_annot_opt: std::mem::ManuallyDrop<Option<A::TypeAnnot>>,
    ____symbol_plus: std::mem::ManuallyDrop<Vec<A::Symbol>>,
    ____rule_plus: std::mem::ManuallyDrop<Vec<A::Rule>>,
    ____action_name_opt: std::mem::ManuallyDrop<Option<A::ActionName>>,
    ____kw_prec_opt: std::mem::ManuallyDrop<Option<()>>,
    ____comma_opt: std::mem::ManuallyDrop<Option<()>>,
    __unit: (),
}
/// Type-safe LR parser.
pub struct MetaParser<A: MetaActions> {
    state_stack: Vec<(usize, Option<(u8, u8)>)>,
    value_stack: Vec<__MetaValue<A>>,
}
impl<A: MetaActions> MetaParser<A> {
    /// Create a new parser instance.
    pub fn new() -> Self {
        Self {
            state_stack: vec![(0, None)],
            value_stack: Vec::new(),
        }
    }
    /// Push a terminal, performing any reductions.
    pub fn push(
        &mut self,
        terminal: MetaTerminal<A>,
        actions: &mut A,
    ) -> Result<(), MetaError> {
        let token_prec = terminal.precedence();
        let symbol_id = terminal.symbol_id().0;
        loop {
            let (state, stack_prec) = self.current_state_and_prec();
            let action = self.lookup_action(state, symbol_id);
            match action & 3 {
                0 => return Err(MetaError { state }),
                1 => {
                    let next_state = (action >> 2) as usize;
                    self.do_shift(terminal, next_state, token_prec);
                    return Ok(());
                }
                2 => {
                    let rule = (action >> 2) as usize;
                    self.do_reduce(rule, actions);
                }
                3 if action != 3 => {
                    let shift_state = ((action >> 3) & 0x3FFF) as usize;
                    let reduce_rule = (action >> 17) as usize;
                    let should_shift = match (stack_prec, token_prec) {
                        (Some((sp, _)), Some((tp, assoc))) => {
                            if tp > sp {
                                true
                            } else if tp < sp {
                                false
                            } else {
                                assoc == 1
                            }
                        }
                        _ => true,
                    };
                    if should_shift {
                        self.do_shift(terminal, shift_state, token_prec);
                        return Ok(());
                    } else {
                        self.do_reduce(reduce_rule, actions);
                    }
                }
                _ => return Err(MetaError { state }),
            }
        }
    }
    /// Finish parsing and return the result.
    pub fn finish(mut self, actions: &mut A) -> Result<A::GrammarDef, MetaError> {
        loop {
            let state = self.current_state();
            let action = self.lookup_action(state, 0);
            match action & 3 {
                2 => {
                    let rule = (action >> 2) as usize;
                    self.do_reduce(rule, actions);
                }
                3 => {
                    if action == 3 {
                        if let Some(union_val) = self.value_stack.pop() {
                            self.state_stack.pop();
                            return Ok(unsafe {
                                std::mem::ManuallyDrop::into_inner(union_val.__grammar_def)
                            });
                        }
                    } else {
                        let reduce_rule = (action >> 17) as usize;
                        self.do_reduce(reduce_rule, actions);
                    }
                }
                _ => return Err(MetaError { state }),
            }
        }
    }
    /// Get the current parser state.
    pub fn state(&self) -> usize {
        self.current_state()
    }
    fn current_state(&self) -> usize {
        self.state_stack.last().unwrap().0
    }
    fn current_state_and_prec(&self) -> (usize, Option<(u8, u8)>) {
        let (state, _) = *self.state_stack.last().unwrap();
        let prec = self.state_stack.iter().rev().find_map(|(_, p)| *p);
        (state, prec)
    }
    fn lookup_action(&self, state: usize, terminal: u32) -> u32 {
        let base = __meta_table::ACTION_BASE[state];
        let index = base.wrapping_add(terminal as i32) as usize;
        if index < __meta_table::ACTION_CHECK.len()
            && __meta_table::ACTION_CHECK[index] == state as u32
        {
            __meta_table::ACTION_DATA[index]
        } else {
            0
        }
    }
    fn lookup_goto(&self, state: usize, non_terminal: u32) -> Option<usize> {
        let base = __meta_table::GOTO_BASE[state];
        let index = base.wrapping_add(non_terminal as i32) as usize;
        if index < __meta_table::GOTO_CHECK.len()
            && __meta_table::GOTO_CHECK[index] == state as u32
        {
            Some(__meta_table::GOTO_DATA[index] as usize)
        } else {
            None
        }
    }
    fn do_shift(
        &mut self,
        terminal: MetaTerminal<A>,
        next_state: usize,
        prec: Option<(u8, u8)>,
    ) {
        self.state_stack.push((next_state, prec));
        match terminal {
            MetaTerminal::Colon => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Plus => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::KwPrec => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::KwGrammar => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::At => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Semi => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Question => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Star => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::KwStart => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Rbrace => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Comma => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::KwTerminals => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Eq => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Lbrace => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::Ident(v) => {
                self.value_stack
                    .push(__MetaValue {
                        __ident: std::mem::ManuallyDrop::new(v),
                    });
            }
            MetaTerminal::Pipe => {
                self.value_stack.push(__MetaValue { __unit: () });
            }
            MetaTerminal::__Phantom(_) => unreachable!(),
        }
    }
    fn do_reduce(&mut self, rule: usize, actions: &mut A) {
        if rule == 0 {
            return;
        }
        let (lhs_id, rhs_len) = __meta_table::RULES[rule];
        let rhs_len = rhs_len as usize;
        for _ in 0..rhs_len {
            self.state_stack.pop();
        }
        let original_rule_idx = rule - 1;
        let value = match original_rule_idx {
            0usize => {
                let _ = self.value_stack.pop().unwrap();
                let v7 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____rule_plus,
                    )
                };
                let v6 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__terminals_block,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                let v4 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                let _ = self.value_stack.pop().unwrap();
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    __grammar_def: std::mem::ManuallyDrop::new(
                        actions.grammar_def(v1, v4, v6, v7),
                    ),
                }
            }
            1usize => {
                let _ = self.value_stack.pop().unwrap();
                let v3 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____comma_opt,
                    )
                };
                let v2 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__terminal_list,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    __terminals_block: std::mem::ManuallyDrop::new(
                        actions.terminals_block(v2, v3),
                    ),
                }
            }
            2usize => {
                let _ = self.value_stack.pop().unwrap();
                let _ = self.value_stack.pop().unwrap();
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    __terminals_block: std::mem::ManuallyDrop::new(
                        actions.terminals_empty(),
                    ),
                }
            }
            3usize => {
                let v2 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__terminal_item,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__terminal_list,
                    )
                };
                __MetaValue {
                    __terminal_list: std::mem::ManuallyDrop::new(
                        actions.terminal_list_append(v0, v2),
                    ),
                }
            }
            4usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__terminal_item,
                    )
                };
                __MetaValue {
                    __terminal_list: std::mem::ManuallyDrop::new(
                        actions.terminal_list_single(v0),
                    ),
                }
            }
            5usize => {
                let v2 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____type_annot_opt,
                    )
                };
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____kw_prec_opt,
                    )
                };
                __MetaValue {
                    __terminal_item: std::mem::ManuallyDrop::new(
                        actions.terminal_item(v0, v1, v2),
                    ),
                }
            }
            6usize => {
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    __type_annot: std::mem::ManuallyDrop::new(actions.type_annot(v1)),
                }
            }
            7usize => {
                let _ = self.value_stack.pop().unwrap();
                let v3 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__alts,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____type_annot_opt,
                    )
                };
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                __MetaValue {
                    __rule: std::mem::ManuallyDrop::new(actions.rule(v0, v1, v3)),
                }
            }
            8usize => {
                let v2 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__alt,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__alts,
                    )
                };
                __MetaValue {
                    __alts: std::mem::ManuallyDrop::new(actions.alts_append(v0, v2)),
                }
            }
            9usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__alt,
                    )
                };
                __MetaValue {
                    __alts: std::mem::ManuallyDrop::new(actions.alts_single(v0)),
                }
            }
            10usize => {
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____action_name_opt,
                    )
                };
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____symbol_plus,
                    )
                };
                __MetaValue {
                    __alt: std::mem::ManuallyDrop::new(actions.alt(v0, v1)),
                }
            }
            11usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____action_name_opt,
                    )
                };
                __MetaValue {
                    __alt: std::mem::ManuallyDrop::new(actions.alt_empty(v0)),
                }
            }
            12usize => {
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    __action_name: std::mem::ManuallyDrop::new(actions.action_name(v1)),
                }
            }
            13usize => {
                let _ = self.value_stack.pop().unwrap();
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                __MetaValue {
                    __symbol: std::mem::ManuallyDrop::new(actions.sym_opt(v0)),
                }
            }
            14usize => {
                let _ = self.value_stack.pop().unwrap();
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                __MetaValue {
                    __symbol: std::mem::ManuallyDrop::new(actions.sym_star(v0)),
                }
            }
            15usize => {
                let _ = self.value_stack.pop().unwrap();
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                __MetaValue {
                    __symbol: std::mem::ManuallyDrop::new(actions.sym_plus(v0)),
                }
            }
            16usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__ident,
                    )
                };
                __MetaValue {
                    __symbol: std::mem::ManuallyDrop::new(actions.sym_plain(v0)),
                }
            }
            17usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__type_annot,
                    )
                };
                __MetaValue {
                    ____type_annot_opt: std::mem::ManuallyDrop::new(Some(v0)),
                }
            }
            18usize => {
                __MetaValue {
                    ____type_annot_opt: std::mem::ManuallyDrop::new(None),
                }
            }
            19usize => {
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__symbol,
                    )
                };
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____symbol_plus,
                    )
                };
                {
                    let mut v0 = v0;
                    v0.push(v1);
                    __MetaValue {
                        ____symbol_plus: std::mem::ManuallyDrop::new(v0),
                    }
                }
            }
            20usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__symbol,
                    )
                };
                __MetaValue {
                    ____symbol_plus: std::mem::ManuallyDrop::new(vec![v0]),
                }
            }
            21usize => {
                let v1 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__rule,
                    )
                };
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().____rule_plus,
                    )
                };
                {
                    let mut v0 = v0;
                    v0.push(v1);
                    __MetaValue {
                        ____rule_plus: std::mem::ManuallyDrop::new(v0),
                    }
                }
            }
            22usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__rule,
                    )
                };
                __MetaValue {
                    ____rule_plus: std::mem::ManuallyDrop::new(vec![v0]),
                }
            }
            23usize => {
                let v0 = unsafe {
                    std::mem::ManuallyDrop::into_inner(
                        self.value_stack.pop().unwrap().__action_name,
                    )
                };
                __MetaValue {
                    ____action_name_opt: std::mem::ManuallyDrop::new(Some(v0)),
                }
            }
            24usize => {
                __MetaValue {
                    ____action_name_opt: std::mem::ManuallyDrop::new(None),
                }
            }
            25usize => {
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    ____kw_prec_opt: std::mem::ManuallyDrop::new(Some(())),
                }
            }
            26usize => {
                __MetaValue {
                    ____kw_prec_opt: std::mem::ManuallyDrop::new(None),
                }
            }
            27usize => {
                let _ = self.value_stack.pop().unwrap();
                __MetaValue {
                    ____comma_opt: std::mem::ManuallyDrop::new(Some(())),
                }
            }
            28usize => {
                __MetaValue {
                    ____comma_opt: std::mem::ManuallyDrop::new(None),
                }
            }
            _ => return,
        };
        self.value_stack.push(value);
        let goto_state = self.current_state();
        let nt_index = lhs_id - __meta_table::NUM_TERMINALS - 1;
        if let Some(next_state) = self.lookup_goto(goto_state, nt_index) {
            self.state_stack.push((next_state, None));
        }
    }
}
impl<A: MetaActions> Default for MetaParser<A> {
    fn default() -> Self {
        Self::new()
    }
}
impl<A: MetaActions> Drop for MetaParser<A> {
    fn drop(&mut self) {
        while let Some(union_val) = self.value_stack.pop() {
            let (state, _) = self.state_stack.pop().unwrap();
            let sym_id = __meta_table::STATE_SYMBOL[state];
            unsafe {
                match sym_id {
                    1u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__ident);
                    }
                    17u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__grammar_def);
                    }
                    18u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__terminals_block);
                    }
                    19u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__terminal_list);
                    }
                    20u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__terminal_item);
                    }
                    21u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__type_annot);
                    }
                    22u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__rule);
                    }
                    23u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__alts);
                    }
                    24u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__alt);
                    }
                    25u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__action_name);
                    }
                    26u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.__symbol);
                    }
                    27u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.____type_annot_opt);
                    }
                    28u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.____symbol_plus);
                    }
                    29u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.____rule_plus);
                    }
                    30u32 => {
                        std::mem::ManuallyDrop::into_inner(
                            union_val.____action_name_opt,
                        );
                    }
                    31u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.____kw_prec_opt);
                    }
                    32u32 => {
                        std::mem::ManuallyDrop::into_inner(union_val.____comma_opt);
                    }
                    _ => {}
                }
            }
        }
    }
}

